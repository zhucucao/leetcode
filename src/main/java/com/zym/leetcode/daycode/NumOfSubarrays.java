package com.zym.leetcode.daycode;

import org.jetbrains.annotations.TestOnly;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
// 1343. 大小为 K 且平均值大于等于阈值的子数组数目
public class NumOfSubarrays {
    public static void main(String[] args) {
       int arr[] = {2,2,2,2,5,5,5,8};
       int k = 3, threshold = 4;
//        int[] arr = {1,1,1,1,1};
//        int k = 1, threshold = 0;
//        int[]arr = {11,13,17,23,29,31,7,5,2,3};
//        int k = 3, threshold = 5;
//        int[]arr = {7,7,7,7,7,7,7};
//        int  k = 7, threshold = 7;
        /**
         * 自己写的解法
         */
//        int[] arr = {3642,8932,8348,8674,2881,4460,4746,9377,7973,8772,410,700,9496,2875,4461,1140,1749,4062,3805,4485,154,8720,5341,1772,7479,388,2696,9986,7589,3005,9484,6530,5973,2894,2056,1992,5311,3908,5000,3859,9971,1992,3750,555,6572,507,6751,4920,2403,7137,7001,722,5404,3089,4668,3653,7812,3141,663,3683,6951,9117,8528,3990,7895,4701,6464,9679,6808,8379,8633,2160,2818,3424,7940,2086,6210,8629,2970,4772,7119,7150,4765,2747,953,8638,2162,5702,61,455,9559,1680,9360,444,8388,2067,724,1484,6497,4769,8548,7266,2681,8345,8144,6750,7289,282,4789,4818,1626,6137,1732,6709,3092,8391,981,3780,310,4980,7798,1049,2604,158,5545,4090,537,3837,7991,9107,5860,8296,155,2141,9667,6802,949,5620,5533,8497,1010,334,631,7091,3292,3730,5548,7,9835,2916,7884,5245,7546,7486,4378,8048,6119,7522,9906,5638,5275,2724,4519,1738,1689,6093,2271,1510,2456,2928,8736,859,915,8266,8640,927,8702,495,6780,1076,7544,5040,9701,3568,9683,7091,8566,909,3209,8430,8815,5969,5333,2087,4557,2137,2406,5276,9353,1941,1123,3704,7758,7077,7741,4323,7784,7452,6460,10,976,8302,9596,8355,1583,5483,6256,3055,9450,2853,3283,5198,9485,1145,1413,5360,6593,8589,7711,542,5981,1104,9156,4566,4564,7043,9141,4221,9998,5347,413,7642,6279,8521,8995,6656,8102,9934,9775,8474,9694,9882,2357,6375,5285,135,6429,6700,4942,8359,150,4878,2189,4249,1323,4735,7903,9686,5453,1588,4296,4902,5719,1783,8065,3306,7721,7797,5048,5204,6081,7958,502,835,5155,8261,724,8709,9413,5259,1595,8294,1846,7433,7824,7063,1495,5639,7709,5529,7538,3548,7441,4268,1937,7804,9456,7900,9508,8682,9340,2956,7842,599,3444,474,2740,4100,7633,9326,7317,790,9618,9537,73,259,4494,8435,7120,3557,3598,4099,4021,5392,9515,8905,6881,7352,8575,2334,1137,3317,8056,1825,4394,6632,181,4832,9108,4638,8820,8890,651,9984,1431,218,7916,6196,1649,4136,7798,7222,1782,8875,7816,3141,28,3806,2125,6893,748,8065,1268,6666,7320,5919,1735,9847,1094,4612,5721,6255,2,1297,117,1548,6394,1112,1935,7273,4017,3871,1822,9698,4875,2268,3031,3654,2929,4582,2426,7804,2726,4066,6360,8569,790,9791,6267,2670,6684,8288,6241,3268,9333,6336,9047,8906,7919,1618,4790,5053,3091,5232,3577,5402,5758,600,5185,7208,7199,1523,8921,8047,8317,648,5044,814,3071,2806,6437,3946,8577,7528,280,7592,2379,494,411,1982,2444,8618,8041,771,8929,8655,797,1115,1177,3162,487,5960,930,1808,9870,3014,5759,1488,8757,4371,8021,7901,713,70,2995,1582,3513,502,1160,7254,6146,6037,8780,6821,6141,835,3376,1740,9113,7952,5779,1503,1349,46,4077,4437,2172,6407,8288,5151,6156,3827,7131,8217,3164,1958,7344,758,7726,2283,5164,1305,8096,5295,4557,439,1564,6534,6289,3242,786,2873,1681,9862,5999,2385,9413,9253,3227,4168,6149,3069,5717,799,4382,2672,1231,8742,8866,3853,7930,7092,8225,8614,5132,299,5718,5988,1893,4297,7754,9012,6856,8117,393,3032,5960,1222,4785,3195,9140,4804,1974,8320,4253,1655,7883,8782,5475,3707,3155,2054,9087,9095,3148,1460,4529,4406,7152,8605,2540,115,8621,5743,2570,7260,7939,9490,2028,6761,8970,7413,7936,4678,9984,4056,3455,5612,5774,4223,7443,9016,3494,1920,2622,5761,2942,2655,4277,6704,6116,8256,9323,8858,1849,8884,8264,4149,2601,3996,6703,1059,8798,6499,9416,9346,9205,5571,6047,6942,3455,1616,3290,8700,3591,3877,4111,8369,9395,7166,5179,1489,2349,9579,7352,2982,4003,273,3703,9478,5137,6978,2309,758,7117,3234,9412,1983,9826,4137,8993,1406,7591,4060,8878,1622,152,2834,3197,3943,8635,7177,549,7087,1235,3522,8525,917,3952,3486,1067,6169,9983,5311,4857,2761,6363,7443,4001,7010,3991,9836,1986,1064,8814,4532,7186,9849,8499,6543,809,2246,699,9767,547,9394,1864,2212,6549,6866,8426,4060,3011,8095,7606,6792,7730,5344,79,8941,5825,8762,1359,5989,6838,3697,6844,7535,3168,8223,6056,2562,7225,5296,6407,8431,6524,3321,2138,3250,7318,154,4740,1274,5258,8251,1298,4373,1014,7323,5049,5479,8376,7414,9019,7667,6903,8479,227,2236,9435,4355,1319,2623,3265,1297,5119,8035,909,4994,5455,3128,3289,6078,7705,221,4348,486,950,924,2578,3182,5709,5797,2278,6380,4060,230,5404,556,7013,4640,5461,7125,3260,1629,8925,456,8878,7774,8179,8184,5063,1608,2396,6336,3209,4119,6,36,3606,5224,2675,8128,6876,3790,3156,4507,798,7151,8687,5710,4526,510,663,3896,3237,9821,4466,2770,6893,9228,4168,2586,6673,1883,4819,1831,4218,4747,9368,4466,2966,7660,2361,7937,6151,7294,8104,6661,3994,5967,6789,8863,8300,5869,5554,3314,5235,6088,2715,7386,7905,1932,8006,5193,6418,7745,653,7573,5287,5881,8567,7832,7075,9231,9419,5682,3118,4083,4609,7816,4829,6585,54,7890,4519,548,9828,7386,512,5697,9287,391,7694,9122,2532,6777,7830,5773,5524,9885,7798,3633,1868,3749,9321,839,5798,144,1144,8522,3018,432,1659,7786,7453,1418,4257,2175,3555,7827,7365,70,8960,2560,9066,5732,1722,2905,7124,4176,9061,4114,84,5348,3603,5505,8715,2713,860,1231};
//        int k = 347;
//        int threshold = 0;
//        int result = NumOfSubarrays2(arr, k, threshold);
//        System.out.println(result);
        /**
         * 滑动窗口算法解决。优点是没有全部重新计算。
         */
//        windowSolve(arr,k,threshold);

        /**
         * 优化自己的方法 不再重复计算sum总和
         */
//        int i = NumOfSubarrays(arr, k, threshold);
//        System.out.println(i);
        /**
         *  前缀和解法
         */
        prefixSumSolve(arr,k,threshold);


    }
    // 前缀和算法  https://www.pianshen.com/article/7331273831/

    /**
     *
     * 1 . 前缀和
     * 其实可以把它理解为数学上的数列的前n项和（对于一个一维数组的前缀和）。
     * 我们定义对于一个数组a的前缀和数组s，s[i] = a[1]+a[2]+...+a[i].
     *
     * 2.前缀和算法是一种重要的预处理算法，能大大降低查询的时间复杂度。最简单的题目就是：给定n个数和m次询问，每次询问一段区间的和。
     *
     * 查找一个区间的和我们可以从加法转换为减法，查询从L到R区间数字的和，其实可以转换为前R之和减去前L-1项之和。如下所示
     *
     * 作者：zhengqiuliu
     * 链接：https://www.jianshu.com/p/ecf4fb5cf99d
     * 来源：简书
     * 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
     */
    public static void prefixSumSolve(int[] arr,int k,int threshold) {
        int res = 0;
        int[] prefixSumArr = new int[arr.length + 1];
        for(int i = 1 ; i < prefixSumArr.length ; i++) {
            prefixSumArr[i] = prefixSumArr[i-1] + arr[i-1];
        }
        for(int x = 0 ; x+k <= arr.length;x++) {
            if((prefixSumArr[x+k] - prefixSumArr[x])/k >= threshold) {
                res++;
            }
        }
        System.out.println(res);

    }
    // 滑动窗口算法 https://www.cnblogs.com/labuladong/p/12320475.html

    public static  void windowSolve(int[] arr, int k, int threshold) {
        // 左指针
        int left = 0;
        // 右指针
        int right = left + k;
        // 总和
        int sum = 0;
        // 满足题设的数量
        int res = 0;
        for(int i = 0 ; i < right ; i++) {
            sum+=arr[i];
        }
        while (right < arr.length){
            if(sum / k >= threshold) {
                res++;
            }
            sum-=arr[left];
            sum+=arr[right];
            left++;
            right++;
        }
        if(sum / k >= threshold) {
            res++;
        }
        System.err.println(res);

    }
    // 也修改为类似滑动窗口 不再重复计算总和。
    public static int NumOfSubarrays(int[] arr, int k, int threshold){
        boolean hasSum = false;
        int totalCount = 0 ;
        int currentNum = 0;
        for(int i = 0 ; i < arr.length ; i++) {
            // 剩余的数组长度不够k长
            if(arr.length - i  < k) {
                return totalCount;
            }
            if(!hasSum) {
                for(int x = i ; x < k+i ; x++) {
                    currentNum += arr[x];
                    hasSum = true;
                }
            } else {
                currentNum = currentNum - arr[i-1];
                currentNum = currentNum + arr[i + k -1];
            }

            if(currentNum / k >= threshold) {
                totalCount++;
            }
        }
        return totalCount;
    }

    public static int NumOfSubarrays2(Integer[] arr, int k, int threshold){
        // 阈值为0 返回数组长度a
//        if(threshold == 0) {
//            return arr.length;
//        }
        List<Integer> list = Arrays.asList(arr);
        int totalCount = 0 ;
        int currentNum = 0;
        for(int i = 0 ; i < list.size() ; i++) {
            currentNum = 0;
            // 剩余的数组长度不够k长
            if(arr.length - i  < k) {
                return totalCount;
            }
            // 主要浪费在总和的重复计算。实际每次只用去除左边的值和增加右边的新值
            for(int x = i ; x < k+i ; x++) {
                currentNum += arr[x];
            }
            if(currentNum / k >= threshold) {
                totalCount++;
            }
        }
        return totalCount;
    }
}
